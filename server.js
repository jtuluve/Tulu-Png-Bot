const { Telegraf } = require("telegraf");
const bot = new Telegraf(process.env.BOT_TOKEN);
const sqlite3 = require("sqlite3").verbose();
const db = new sqlite3.Database("userdata.db");
const http = require('https');
db.run(
  "CREATE TABLE IF NOT EXISTS userdata (userid INTEGER UNIQUE, color TEXT DEFAULT 'red', font TEXT DEFAULT 'baravu', pngcount INTEGER DEFAULT 0,lastcommand TEXT DEFAULT '/start')"
);
// Bot code
//bot.telegram.setWebhook('https://mesquite-private-jay.glitch.me/');

bot.on("message", (ctx, next) => {
  db.get(
    "SELECT userId FROM userdata WHERE userId = ?",
    [ctx.update.message.from.id],
    (err, row) => {
      if (err) {
        console.error(err.message);
      } else {
        if (!row) {
          // userId does not exist in the table, insert a new row with default values
          db.run(
            "INSERT INTO userdata (userId, pngCount) VALUES (?, ?)",
            [ctx.update.message.from.id, 0],
            (err) => {
              if (err) {
                console.error(err.message);
              }
            }
          );
        }
      }
    }
  );
  console.log(__dirname);
  next();
});

bot.command(["help", "start"], (ctx) => {
  ctx.replyWithMarkdown(
    "‚ö†Ô∏è *Read this before using this bot* ‚ö†Ô∏è\nNote:\n- This bot returns png image in Tulu Script... \n- You can send texts using Kannada or Malayalam script and in Tulu language to get png image\n- Send your text directly without any commands to transcript"
  );
  console.log(ctx);
});

// Command to set user color
bot.command("setcolor", (ctx) => {
  const color = ctx.message.text.split(" ")[1];

  // Array of allowed colors
  const colors = [
    "black",
    "white",
    "red",
    "green",
    "blue",
    "yellow",
    "cyan",
    "gray",
    "orange",
    "brown",
    "purple",
    "pink",
    "olive",
    "navy",
    "maroon",
    "teal",
    "gold",
    "indigo",
    "silver",
    "turquoise",
    "violet",
    "salmon",
    "tan",
    "wheat",
  ];
  const colorsString = colors.join(", ");
  // Check if the given color is allowed
  if (color && colors.includes(color)) {
    db.get(
      "SELECT * FROM userdata WHERE userid = ?",
      [ctx.update.message.from.id],
      (err, row) => {
        if (err) {
          console.error(err.message);
        }
        // if userr exists, update color value
        if (row) {
          db.run(
            "UPDATE userdata SET color = ? WHERE userid = ?",
            [color, ctx.update.message.from.id],
            (err) => {
              if (err) {
                console.error(err.message);
              }
              console.log(
                `Color value updated for user ${ctx.update.message.from.id}`
              );
            }
          );
        }
        // if user does not exist, create new row with userid and color
        else {
          db.run(
            "INSERT INTO userdata (userid, color) VALUES (?, ?)",
            [ctx.update.message.from.id, color],
            (err) => {
              if (err) {
                console.error(err.message);
              }
              console.log(
                `New row added for user ${ctx.update.message.from.id}`
              );
            }
          );
        }
      }
    );
    // Reply with confirmation message
    ctx.reply(`Your text color has been set to ${color}`);
  } else {
    // Reply with error message
    ctx.reply(
      `Itseems you did something wrong. Please run the command as /setcolor {color}\nExample: /setcolor black\n available colors: ${colorsString}`
    );
  }
  console.log(ctx);
});

bot.command("setfont", (ctx) => {
  const font = ctx.message.text.split(" ")[1];

  // Array of allowed fonts
  const fonts = ["baravu", "allige", "mandara"];

  // Check if the given font is allowed
  if (font && fonts.includes(font)) {
    db.get(
      "SELECT * FROM userdata WHERE userid = ?",
      [ctx.update.message.from.id],
      (err, row) => {
        if (err) {
          console.error(err.message);
        }
        // if user exists, update font value
        if (row) {
          db.run(
            "UPDATE userdata SET font = ? WHERE userid = ?",
            [font, ctx.update.message.from.id],
            (err) => {
              if (err) {
                console.error(err.message);
              }
              console.log(
                `Font value updated for user ${ctx.update.message.from.id}`
              );
            }
          );
        }
        // if user does not exist, create new row with userid and font
        else {
          db.run(
            "INSERT INTO userdata (userid, font) VALUES (?, ?)",
            [ctx.update.message.from.id, font],
            (err) => {
              if (err) {
                console.error(err.message);
              }
              console.log(
                `New row added for user ${ctx.update.message.from.id}`
              );
            }
          );
        }
      }
    );
    // Reply with confirmation message
    ctx.reply(`Your font has been set to ${font}`);
  } else {
    // Reply with error message
    ctx.reply(
      `It seems you did something wrong. Please run the command as /setfont {font}\nExample: /setfont baravu\nAvailable fonts: ${fonts}`
    );
  }
  console.log(ctx);
});

bot.command("fonts", (ctx) => {
  const fonts = ["baravu", "allige", "mandara"];
  const fontsString = fonts.join(", ");
  ctx.reply("available fonts: " + fontsString);
});

bot.command("colors", (ctx) => {
  const colors = [
    "black",
    "white",
    "red",
    "green",
    "blue",
    "yellow",
    "cyan",
    "magenta",
    "gray",
    "orange",
    "brown",
    "purple",
    "pink",
    "olive",
    "navy",
    "maroon",
    "teal",
    "coral",
    "gold",
    "khaki",
    "indigo",
    "silver", "turquoise", "violet", "beige", "orchid", "plum", "salmon", "sienna", "tan", "wheat",];
  const colorsString = colors.join(", ");
  ctx.reply("available colors: " + colorsString);
});

bot.on("sticker", (ctx) => ctx.reply("üôÑ"));

bot.on("text", (ctx) => {
  let txt = ctx.message.text;
  
  txt = transcript(txt);
txt = encodeURIComponent(txt)
  db.get(
    "SELECT * FROM userdata WHERE userid = ?",
    [ctx.update.message.from.id],
    (err, row) => {
      if (err) {
        console.error(err.message);
      } else if (!row) {
const options = {
  hostname: `mesquite-private-jay.glitch.me`,
  path: `/image?text=${txt}&font=baravu&color=red`,
  port: 3000,
  method: 'GET'
};

const req = http.request(options, (res) => {
  ctx.sendDocument({ url: "https://mesquite-private-jay.glitch.me/outputt.png", filename: "image.png" });
        });
req.on('error', error => {
  console.error(error);
});
req.setTimeout(10000, () => {
  req.abort(); // abort the request if it takes more than 5 seconds
  console.error('Request timed out');
});
req.end();
} else {
let color = row.color || "red";
let font = row.font || "baravu"
const axios = require('axios');

axios.get(`https://tulu-png-api.glitch.me/image?text=${txt}&font=${font}&color=${color}`, { timeout: 150000 })
  .then(response => {
    ctx.sendDocument({ url: response.data.url, filename: "image.png" });
  })
  .catch(error => {
    // handle error here
    console.error(error);
  });
/*const options = {
  hostname: `mesquite-private-jay.glitch.me`,
  path: `/image?text=${txt}&font=${font}&color=${color}`,
  method: 'GET',
  timeout: 10000
};

const req = http.request(options, (res) => {
  ctx.sendDocument({ url: 'https://mesquite-private-jay.glitch.me/outputt.png', filename: "image.png" });
  res.on('data', (d) => {
    process.stdout.write(d);
  });
});

req.on('error', (e) => {
  console.error(e);
});
req.setTimeout(10000, () => {
  req.abort(); // abort the request if it takes more than 5 seconds
  console.error('Request timed out');
});
req.end();*/
console.log(txt)
        
        }
    }
  );
  db.run(
    "UPDATE userdata SET pngCount = pngCount + ? WHERE userId = ?",
    [1, ctx.update.message.from.id],
    (err) => {
      if (err) {
        console.error(err.message);
      }
    }
  );
  db.all(
    "SELECT * FROM userdata WHERE userId = ?",
    [ctx.update.message.from.id],
    (err, rows) => {
      if (err) {
        console.error(err.message);
      } else {
        console.log(rows);
      }
    }
  );
});
bot.launch({
  webhook:{
    domain: "https://tulu-png-bot-1.jtuluve.repl.co",
    port: process.env.PORT
  }
});

// ** transliterate function **
function transcript(txt) { 
  txt = txt.replace(/‡≥ç‚Äç/g, "√§").replace(/‚Äç/g, "");

  let E = txt.indexOf("‡≥Ü*");
  let N = txt.indexOf("‡≥Ü*");
  let M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡≥ç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "o" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡≥Ü*");
    N = txt.indexOf("‡≥Ü*");
    M = 1;
  }

  E = txt.indexOf("‡≥á*");
  N = txt.indexOf("‡≥á*");
  M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡≥ç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "O" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡≥á*");
    N = txt.indexOf("‡≥á*");
    M = 1;
  }

  txt = txt
    .replace(/‡≤é\*/g, "oA")
    .replace(/‡≤è\*/g, "OA")
    .replace(/‡≥Å\*/g, "uAX")
    .replace(/‡≤â\*/g, "XAuAX");

  txt = txt.replace(/‡≥Ü‡≥ñ/g, "‡≥à").replace(/‡≥ä‡≥ñ/g, "‡≥ña");

  let e = txt.indexOf("‡≥ñ");
  let n = txt.indexOf("‡≥ñ");
  let m = 1;
  while (e > -1) {
    if (/‡≤æ|‡≤ø|‡≥Ä|‡≥Å|‡≥Ç|‡≥É|‡≥Ü|‡≥á|‡≥ä|‡≥ã|‡≥å/.test(txt[e - 1])) {
      n = n - 1;
      m = 2;
    }
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "ee" + txt.slice(e - m, e) + txt.slice(e + 1);

    e = txt.indexOf("‡≥ñ");
    n = txt.indexOf("‡≥ñ");
    m = 1;
  }

  e = txt.indexOf("‡≥Ü");
  n = txt.indexOf("‡≥Ü");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡≥Ü");
    n = txt.indexOf("‡≥Ü");
    m = 1;
  }

  e = txt.indexOf("‡≥á");
  n = txt.indexOf("‡≥á");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    //replace ‡≥á with E
    txt = txt.slice(0, e - m) + "E" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡≥á");
    n = txt.indexOf("‡≥á");
    m = 1;
  }

  e = txt.indexOf("‡≥à");
  n = txt.indexOf("‡≥à");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "ee" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡≥à");
    n = txt.indexOf("‡≥à");
    m = 1;
  }

  e = txt.indexOf("‡≥ä");
  n = txt.indexOf("‡≥ä");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡≥ä");
    n = txt.indexOf("‡≥ä");
    m = 1;
  }

  e = txt.indexOf("‡≥ã");
  n = txt.indexOf("‡≥ã");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "F" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡≥ã");
    n = txt.indexOf("‡≥ã");
    m = 1;
  }

  let H = txt.indexOf("‡≤∞‡≥ç");
  let ra2 = txt[H + 2];

  while (H > -1) {
    if (
      /‡≤ï|‡≤ñ|‡≤ó|‡≤ò|‡≤ô|‡≤ö|‡≤õ|‡≤ú|‡≤ù|‡≤û|‡≤ü|‡≤†|‡≤°|‡≤¢|‡≤£|‡≤§|‡≤•|‡≤¶|‡≤ß|‡≤®|‡≤™|‡≤´|‡≤¨|‡≤≠|‡≤Æ|‡≤Ø|‡≤≤|‡≤µ|‡≤∂|‡≤∑|‡≤∏|‡≤π|‡≤≥/.test(
        ra2
      ) &&
      txt[H - 1] !== "‡≥ç"
    ) {
      txt = txt.slice(0, H) + txt[H + 2] + "f" + txt.slice(H + 3);
      H = txt.indexOf("‡≤∞‡≥ç");
      ra2 = txt[H + 2];
    } else {
      txt = txt.replace("‡≤∞‡≥ç", "rA");
      H = txt.indexOf("‡≤∞‡≥ç");
      ra2 = txt[H + 2];
    }
  }

  txt = txt
    .replace(/‡≤Ö/g, "XAA")
    .replace(/‡≤Ü/g, "XAa")
    .replace(/‡≤á/g, "XAi")
    .replace(/‡≤à/g, "XAI")
    .replace(/‡≤â/g, "XAu")
    .replace(/‡≤ä/g, "XAU")
    .replace(/‡≤ã/g, "XAR")
    .replace(/‡≥†/g, "XARR")
    .replace(/‡≤é/g, "eA")
    .replace(/‡≤è/g, "EA")
    .replace(/‡≤ê/g, "eeA")
    .replace(/‡≤í/g, "eAa")
    .replace(/‡≤ì/g, "FAa")
    .replace(/‡≤î/g, "XAY")
    .replace(/‡≤Ç/g, "M")
    .replace(/‡≤É/g, "H")
    .replace(/‡≤ï/g, "k")
    .replace(/‡≤ñ/g, "K")
    .replace(/‡≤ó/g, "g")
    .replace(/‡≤ò/g, "G")
    .replace(/‡≤ô/g, "Z")
    .replace(/‡≤ö/g, "c")
    .replace(/‡≤õ/g, "C")
    .replace(/‡≤ú/g, "j")
    .replace(/‡≤ù/g, "J")
    .replace(/‡≤û/g, "z")
    .replace(/‡≤ü/g, "q")
    .replace(/‡≤†/g, "Q")
    .replace(/‡≤°/g, "w")
    .replace(/‡≤¢/g, "W")
    .replace(/‡≤£/g, "N")
    .replace(/‡≤§/g, "t")
    .replace(/‡≤•/g, "T")
    .replace(/‡≤¶/g, "d")
    .replace(/‡≤ß/g, "D")
    .replace(/‡≤®/g, "n")
    .replace(/‡≤™/g, "p")
    .replace(/‡≤´/g, "P")
    .replace(/‡≤¨/g, "b")
    .replace(/‡≤≠/g, "B")
    .replace(/‡≤Æ/g, "m")
    .replace(/‡≤Ø/g, "y")
    .replace(/‡≤∞/g, "r")
    .replace(/‡≤≤/g, "l")
    .replace(/‡≤µ/g, "v")
    .replace(/‡≤∂/g, "S")
    .replace(/‡≤∑/g, "x")
    .replace(/‡≤∏/g, "s")
    .replace(/‡≤π/g, "h")
    .replace(/‡≤≥/g, "L")
    .replace(/‡≥û/g, "L")
    .replace(/‡≤±/g, "xxrhaxx")
    .replace(/‡≥ç/g, "A")
    .replace(/‡≤æ/g, "a")
    .replace(/‡≥Å/g, "u")
    .replace(/‡≥Ç/g, "U")
    .replace(/‡≥å/g, "Y")
    .replace(/‡≤ø/g, "i")
    .replace(/‡≥Ä/g, "I")
    .replace(/‡≥É/g, "R")
    .replace(/‚Äå/g, "X")
    .replace(/‚Äç/g, "")
    .replace(/√§/g, "A");

  //malayalam

  txt = txt.replace(/‡µç‚Äç/g, "√§");

  E = txt.indexOf("‡µÜ*");
  N = txt.indexOf("‡µÜ*");
  M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡µç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "o" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡µÜ*");
    N = txt.indexOf("‡µÜ*");
    M = 1;
  }

  E = txt.indexOf("‡µá*");
  N = txt.indexOf("‡µá*");
  M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡µç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "O" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡µá*");
    N = txt.indexOf("‡µá*");
    M = 1;
  }

  txt = txt
    .replace(/‡¥é\*/g, "oA")
    .replace(/‡¥è\*/g, "OA")
    .replace(/‡µÅ\*/g, "uAX")
    .replace(/‡¥â\*/g, "XAuAX");

  txt = txt.replace(/‡µÜ‡µà/g, "‡µà").replace(/‡µä‡µà/g, "‡µàa");

  //replace ‡µÜ with e
  e = txt.indexOf("‡µÜ");
  n = txt.indexOf("‡µÜ");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡µÜ");
    n = txt.indexOf("‡µÜ");
    m = 1;
  }

  //replace ‡µá with E
  e = txt.indexOf("‡µá");
  n = txt.indexOf("‡µá");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "E" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡µá");
    n = txt.indexOf("‡µá");
    m = 1;
  }

  //replace ‡µà with ee
  e = txt.indexOf("‡µà");
  n = txt.indexOf("‡µà");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "ee" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡µà");
    n = txt.indexOf("‡µà");
    m = 1;
  }

  e = txt.indexOf("‡µä");
  n = txt.indexOf("‡µä");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡µä");
    n = txt.indexOf("‡µä");
    m = 1;
  }

  e = txt.indexOf("‡µã");
  n = txt.indexOf("‡µã");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "F" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡µã");
    n = txt.indexOf("‡µã");
    m = 1;
  }

  H = txt.indexOf("‡¥∞‡µç");
  ra2 = txt[H + 2];
  while (H > -1) {
    if (
      /‡¥ï|‡¥ñ|‡¥ó|‡¥ò|‡¥ô|‡¥ö|‡¥õ|‡¥ú|‡¥ù|‡¥û|‡¥ü|‡¥†|‡¥°|‡¥¢|‡¥£|‡¥§|‡¥•|‡¥¶|‡¥ß|‡¥®|‡¥™|‡¥´|‡¥¨|‡¥≠|‡¥Æ|‡¥Ø|‡¥≤|‡¥µ|‡¥∂|‡¥∑|‡¥∏|‡¥π|‡¥≥/.test(
        ra2
      ) &&
      txt[H - 1] !== "‡µç"
    ) {
      txt = txt.slice(0, H) + txt[H + 2] + "f" + txt.slice(H + 3);
      H = txt.indexOf("‡¥∞‡µç");
      ra2 = txt[H + 2];
    } else {
      txt = txt.replace("‡¥∞‡µç", "rA");
      H = txt.indexOf("‡¥∞‡µç");
      ra2 = txt[H + 2];
    }
  }

  H = txt.indexOf("‡µº");
  ra2 = txt[H + 1];
  while (H > -1) {
    if (
      /‡¥ï|‡¥ñ|‡¥ó|‡¥ò|‡¥ô|‡¥ö|‡¥õ|‡¥ú|‡¥ù|‡¥û|‡¥ü|‡¥†|‡¥°|‡¥¢|‡¥£|‡¥§|‡¥•|‡¥¶|‡¥ß|‡¥®|‡¥™|‡¥´|‡¥¨|‡¥≠|‡¥Æ|‡¥Ø|‡¥≤|‡¥µ|‡¥∂|‡¥∑|‡¥∏|‡¥π|‡¥≥/.test(
        ra2
      ) &&
      txt[H - 1] !== "‡µç"
    ) {
      txt = txt.slice(0, H) + txt[H + 1] + "f" + txt.slice(H + 2);
      H = txt.indexOf("‡µº");
      ra2 = txt[H + 1];
    } else {
      txt = txt.replace("‡µº", "rA");
      H = txt.indexOf("‡µº");
      ra2 = txt[H + 1];
    }
  }

  txt = txt
    .replace(/‡¥Ö/g, "XAA")
    .replace(/‡¥Ü/g, "XAa")
    .replace(/‡¥á/g, "XAi")
    .replace(/‡¥à/g, "XAI")
    .replace(/‡¥â/g, "XAu")
    .replace(/‡¥ä/g, "XAU")
    .replace(/‡¥ã/g, "XAR")
    .replace(/‡µ†/g, "XARR")
    .replace(/‡µÑ/g, "RR")
    .replace(/‡¥é/g, "eA")
    .replace(/‡¥è/g, "EA")
    .replace(/‡¥ê/g, "eeA")
    .replace(/‡¥í/g, "eAa")
    .replace(/‡¥ì/g, "FAa")
    .replace(/‡¥î/g, "AY")
    .replace(/‡µó/g, "Y")
    .replace(/‡¥Ç/g, "M")
    .replace(/‡¥É/g, "H")
    .replace(/‡¥ï/g, "k")
    .replace(/‡¥ñ/g, "K")
    .replace(/‡¥ó/g, "g")
    .replace(/‡¥ò/g, "G")
    .replace(/‡¥ô/g, "Z")
    .replace(/‡¥ö/g, "c")
    .replace(/‡¥õ/g, "C")
    .replace(/‡¥ú/g, "j")
    .replace(/‡¥ù/g, "J")
    .replace(/‡¥û/g, "z")
    .replace(/‡¥ü/g, "q")
    .replace(/‡¥†/g, "Q")
    .replace(/‡¥°/g, "w")
    .replace(/‡¥¢/g, "W")
    .replace(/‡¥£/g, "N")
    .replace(/‡¥§/g, "t")
    .replace(/‡¥•/g, "T")
    .replace(/‡¥¶/g, "d")
    .replace(/‡¥ß/g, "D")
    .replace(/‡¥®/g, "n")
    .replace(/‡¥™/g, "p")
    .replace(/‡¥´/g, "P")
    .replace(/‡¥¨/g, "b")
    .replace(/‡¥≠/g, "B")
    .replace(/‡¥Æ/g, "m")
    .replace(/‡¥Ø/g, "y")
    .replace(/‡¥∞/g, "r")
    .replace(/‡¥≤/g, "l")
    .replace(/‡¥µ/g, "v")
    .replace(/‡¥∂/g, "S")
    .replace(/‡¥∑/g, "x")
    .replace(/‡¥∏/g, "s")
    .replace(/‡¥π/g, "h")
    .replace(/‡¥≥/g, "L")
    .replace(/‡µç/g, "A")
    .replace(/‡¥æ/g, "a")
    .replace(/‡µÅ/g, "u")
    .replace(/‡µÇ/g, "U")
    .replace(/‡µà/g, "Y")
    .replace(/‡¥ø/g, "i")
    .replace(/‡µÄ/g, "I")
    .replace(/‡µÉ/g, "R")
    .replace(/‚Äç/g, "X")
    .replace(/‚Äå/g, "X")
    .replace(/√§/g, "A");
  txt = txt
    .replace(/A /g, "A  ")
    .replace(/‡¥±/g, "r")
    .replace(/‡¥¥/g, "L")
    .replace(/‡µº/g, "rA")
    .replace(/‡µª/g, "nA")
    .replace(/‡µ∫/g, "NA")
    .replace(/‡µΩ/g, "lA")
    .replace(/‡µæ/g, "LA");

  let fa = txt.indexOf("fA");
  while (fa > -1) {
    var tt = [
      "k",
      "K",
      "g",
      "G",
      "Z",
      "c",
      "C",
      "j",
      "J",
      "z",
      "q",
      "Q",
      "w",
      "W",
      "N",
      "t",
      "T",
      "d",
      "D",
      "n",
      "p",
      "P",
      "b",
      "B",
      "m",
      "y",
      "r",
      "l",
      "v",
      "S",
      "x",
      "s",
      "h",
      "L",
    ];

    if (tt.includes(txt[fa + 2])) {
      txt = txt.slice(0, fa) + "fXA" + txt.slice(fa + 2);
    }

    fa = txt.indexOf("fA", fa + 2);
  }

  return txt;
}


