//local process env
require('dotenv').config();
//imports
const { Telegraf, Markup } = require("telegraf");
const { message } = require("telegraf/filters")
const sqlite3 = require("sqlite3").verbose();
const axios = require('axios');

//database
const db = new sqlite3.Database("userdata.db");

//create userdata table if not exists
db.run(`CREATE TABLE IF NOT EXISTS userdata (userid INTEGER UNIQUE, color STRING DEFAULT 'red', font STRING DEFAULT baravu)`)
const bot = new Telegraf(process.env.BOT_TOKEN);
//const http = require('https');
// Bot code
//bot.telegram.setWebhook('https://mesquite-private-jay.glitch.me/');

bot.on(message, (ctx, next) => {
  dbcreate(ctx.chat.id)
  return next();
})
bot.command(["start"], (ctx) => {
  ctx.replyWithMarkdownV2(
    "*Hello there\\!\\! Read this before using the bot*\nI can send a png image in *Tulu script* if you provide the text in *Kannada or Malayalam script*\\. \n You can select your own color and font\\. \nFor a list of available commands send /commands or /help\\.");
});

// Command to set user color
bot.command('setcolor', async (ctx) => {
  return await ctx.reply('choose color:', Markup.inlineKeyboard([
    [
      Markup.button.callback("black", "setcolor black"),
      Markup.button.callback("white", "setcolor white"),
      Markup.button.callback("red", "setcolor red"),
    ], [
      Markup.button.callback("green", "setcolor green"),
      Markup.button.callback("blue", "setcolor blue"),
      Markup.button.callback("yellow", "setcolor yellow")
    ], [
      Markup.button.callback("cyan", "setcolor cyan"),
      Markup.button.callback("gray", "setcolor gray"),
      Markup.button.callback("orange", "setcolor orange")
    ], [
      Markup.button.callback("brown", "setcolor brown"),
      Markup.button.callback("purple", "setcolor purple"),
      Markup.button.callback("pink", "setcolor pink")
    ], [
      Markup.button.callback("maroon", "setcolor maroon"),
      Markup.button.callback("violet", "setcolor violet"),
      Markup.button.callback("gold", "setcolor gold")
    ]
  ])
  )
});
//user color set action
bot.action(/setcolor (.+)/, async (ctx) => {
  await dbupdate(ctx.update.callback_query.from.id, ["color"], [ctx.match[1]])
  ctx.reply(`Your color has been updated to ${ctx.match[1]}`)
  return
})


bot.command("setfont", async (ctx) => {
  return await ctx.reply('choose font:', Markup.inlineKeyboard([
    [
      Markup.button.callback("baravu", "setfont baravu"),
      Markup.button.callback("mandara", "setfont mandara"),
      Markup.button.callback("allige", "setfont allige"),
    ]
  ])
  )
});

//user font set action
bot.action(/setfont (.+)/, (ctx) => {
  ctx.reply(`Your font has been updated to: ${ctx.match[1]}`)
  dbupdate(ctx.update.callback_query.from.id, ["font"], [ctx.match[1]])
  return
})

bot.on(message("sticker"), (ctx) => ctx.reply("üôÑ"));

bot.command("mycolor", (ctx) => {
  dbget(ctx.message.from.id, (row) => {
    if (row)
      ctx.reply(`Your default png color is ${row.color}`)
    else ctx.reply("Your default png color is red")
  })
})

bot.command("myfont", (ctx) => {
  dbget(ctx.message.from.id, (row) => {
    if (row)
      ctx.reply(`Your default png font is ${row.font}`)
    else ctx.reply("Your default png font is baravu")
  })
})

bot.command("image", (ctx)=>{
  ctx.reply("Send me the text in Kannada or Malyalam (in Tulu language) to get png image.")
})

bot.command(["commands","command", "help"], ctx=>{
  ctx.replyWithMarkdownV2("*Here is a list of available commands and their  short description:*\n/start \\- Get started\\!\\!\n/image \\- Generate png image\n/setfont \\- Set font for png text\n/setcolor \\- set color for png text\n/myfont \\- currently selected font\n/mycolor \\- currently selected color\n/commands \\- get a list of available commands")
})

bot.on(message("text"), async (ctx) => {
  let msg = await bot.telegram.sendMessage(ctx.message.from.id, "It will take some time for me to generate png. Please wait..üòá")
  console.log(msg)
  dbget(ctx.message.chat.id, async (row) => {
    let txt = ctx.message.text;

    txt = transcript(txt);
    txt = encodeURIComponent(txt);
    let color = row ? row.color : "red";
    let font = row ? row.font : "baravu";

    axios.get(`https://tulu-png-api.glitch.me/image?text=${txt}&font=${font}&color=${color}`)
      .then(response => {
        ctx.sendDocument({ url: response.data.url, filename: "image.png" });
        bot.telegram.deleteMessage(ctx.message.from.id, msg.message_id);
      })
      .catch(error => {
        console.error(error);
      });
  })


});
bot.launch(/*{
  webhook:{
    domain: "",
    port: process.env.PORT
  }
}*/)
.then(()=>{
  console.log("listening..")
})

async function dbupdate(userid, key, values) {
  if (key.length !== values.length) { console.log("key values length difference error"); return }
  await dbcreate(userid);
  let sqlQuery = ""
  for (let i = 0; i < key.length; i++) {
    sqlQuery += `${key[i]}="${values[i]}",`
  }
  sqlQuery = sqlQuery.slice(0, -1);
  await db.run(`UPDATE userdata SET ${sqlQuery} WHERE userid = ${userid}`, (err) => { if (err) console.log(err) })
}

function dbget(userid, callback) {
  db.get(`SELECT * FROM userdata WHERE userid = ${userid}`, (err, row) => {
    if (row) callback(row)
    else callback(null)
  })
  return
}
function dbcreate(userid) {
  db.run(`INSERT INTO userdata(userid) SELECT ${userid} WHERE NOT EXISTS (SELECT * FROM userdata WHERE userid=${userid})`, (err) => { if (err) console.log(err) })
}
async function dbdelete(userid) {
  db.run(`DELETE FROM userdata WHERE userid=${userid}`, (err) => { if (err) console.log(err) })
  return
}

// ** transliterate function **
function transcript(txt) {
  txt = txt.replace(/‡≥ç‚Äç/g, "√§").replace(/‚Äç/g, "");

  let E = txt.indexOf("‡≥Ü*");
  let N = txt.indexOf("‡≥Ü*");
  let M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡≥ç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "o" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡≥Ü*");
    N = txt.indexOf("‡≥Ü*");
    M = 1;
  }

  E = txt.indexOf("‡≥á*");
  N = txt.indexOf("‡≥á*");
  M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡≥ç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "O" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡≥á*");
    N = txt.indexOf("‡≥á*");
    M = 1;
  }

  txt = txt
    .replace(/‡≤é\*/g, "oA")
    .replace(/‡≤è\*/g, "OA")
    .replace(/‡≥Å\*/g, "uAX")
    .replace(/‡≤â\*/g, "XAuAX");

  txt = txt.replace(/‡≥Ü‡≥ñ/g, "‡≥à").replace(/‡≥ä‡≥ñ/g, "‡≥ña");

  let e = txt.indexOf("‡≥ñ");
  let n = txt.indexOf("‡≥ñ");
  let m = 1;
  while (e > -1) {
    if (/‡≤æ|‡≤ø|‡≥Ä|‡≥Å|‡≥Ç|‡≥É|‡≥Ü|‡≥á|‡≥ä|‡≥ã|‡≥å/.test(txt[e - 1])) {
      n = n - 1;
      m = 2;
    }
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "ee" + txt.slice(e - m, e) + txt.slice(e + 1);

    e = txt.indexOf("‡≥ñ");
    n = txt.indexOf("‡≥ñ");
    m = 1;
  }

  e = txt.indexOf("‡≥Ü");
  n = txt.indexOf("‡≥Ü");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡≥Ü");
    n = txt.indexOf("‡≥Ü");
    m = 1;
  }

  e = txt.indexOf("‡≥á");
  n = txt.indexOf("‡≥á");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    //replace ‡≥á with E
    txt = txt.slice(0, e - m) + "E" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡≥á");
    n = txt.indexOf("‡≥á");
    m = 1;
  }

  e = txt.indexOf("‡≥à");
  n = txt.indexOf("‡≥à");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "ee" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡≥à");
    n = txt.indexOf("‡≥à");
    m = 1;
  }

  e = txt.indexOf("‡≥ä");
  n = txt.indexOf("‡≥ä");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡≥ä");
    n = txt.indexOf("‡≥ä");
    m = 1;
  }

  e = txt.indexOf("‡≥ã");
  n = txt.indexOf("‡≥ã");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡≥ç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "F" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡≥ã");
    n = txt.indexOf("‡≥ã");
    m = 1;
  }

  let H = txt.indexOf("‡≤∞‡≥ç");
  let ra2 = txt[H + 2];

  while (H > -1) {
    if (
      /‡≤ï|‡≤ñ|‡≤ó|‡≤ò|‡≤ô|‡≤ö|‡≤õ|‡≤ú|‡≤ù|‡≤û|‡≤ü|‡≤†|‡≤°|‡≤¢|‡≤£|‡≤§|‡≤•|‡≤¶|‡≤ß|‡≤®|‡≤™|‡≤´|‡≤¨|‡≤≠|‡≤Æ|‡≤Ø|‡≤≤|‡≤µ|‡≤∂|‡≤∑|‡≤∏|‡≤π|‡≤≥/.test(
        ra2
      ) &&
      txt[H - 1] !== "‡≥ç"
    ) {
      txt = txt.slice(0, H) + txt[H + 2] + "f" + txt.slice(H + 3);
      H = txt.indexOf("‡≤∞‡≥ç");
      ra2 = txt[H + 2];
    } else {
      txt = txt.replace("‡≤∞‡≥ç", "rA");
      H = txt.indexOf("‡≤∞‡≥ç");
      ra2 = txt[H + 2];
    }
  }

  txt = txt
    .replace(/‡≤Ö/g, "XAA")
    .replace(/‡≤Ü/g, "XAa")
    .replace(/‡≤á/g, "XAi")
    .replace(/‡≤à/g, "XAI")
    .replace(/‡≤â/g, "XAu")
    .replace(/‡≤ä/g, "XAU")
    .replace(/‡≤ã/g, "XAR")
    .replace(/‡≥†/g, "XARR")
    .replace(/‡≤é/g, "eA")
    .replace(/‡≤è/g, "EA")
    .replace(/‡≤ê/g, "eeA")
    .replace(/‡≤í/g, "eAa")
    .replace(/‡≤ì/g, "FAa")
    .replace(/‡≤î/g, "XAY")
    .replace(/‡≤Ç/g, "M")
    .replace(/‡≤É/g, "H")
    .replace(/‡≤ï/g, "k")
    .replace(/‡≤ñ/g, "K")
    .replace(/‡≤ó/g, "g")
    .replace(/‡≤ò/g, "G")
    .replace(/‡≤ô/g, "Z")
    .replace(/‡≤ö/g, "c")
    .replace(/‡≤õ/g, "C")
    .replace(/‡≤ú/g, "j")
    .replace(/‡≤ù/g, "J")
    .replace(/‡≤û/g, "z")
    .replace(/‡≤ü/g, "q")
    .replace(/‡≤†/g, "Q")
    .replace(/‡≤°/g, "w")
    .replace(/‡≤¢/g, "W")
    .replace(/‡≤£/g, "N")
    .replace(/‡≤§/g, "t")
    .replace(/‡≤•/g, "T")
    .replace(/‡≤¶/g, "d")
    .replace(/‡≤ß/g, "D")
    .replace(/‡≤®/g, "n")
    .replace(/‡≤™/g, "p")
    .replace(/‡≤´/g, "P")
    .replace(/‡≤¨/g, "b")
    .replace(/‡≤≠/g, "B")
    .replace(/‡≤Æ/g, "m")
    .replace(/‡≤Ø/g, "y")
    .replace(/‡≤∞/g, "r")
    .replace(/‡≤≤/g, "l")
    .replace(/‡≤µ/g, "v")
    .replace(/‡≤∂/g, "S")
    .replace(/‡≤∑/g, "x")
    .replace(/‡≤∏/g, "s")
    .replace(/‡≤π/g, "h")
    .replace(/‡≤≥/g, "L")
    .replace(/‡≥û/g, "L")
    .replace(/‡≤±/g, "xxrhaxx")
    .replace(/‡≥ç/g, "A")
    .replace(/‡≤æ/g, "a")
    .replace(/‡≥Å/g, "u")
    .replace(/‡≥Ç/g, "U")
    .replace(/‡≥å/g, "Y")
    .replace(/‡≤ø/g, "i")
    .replace(/‡≥Ä/g, "I")
    .replace(/‡≥É/g, "R")
    .replace(/‚Äå/g, "X")
    .replace(/‚Äç/g, "")
    .replace(/√§/g, "A");

  //malayalam

  txt = txt.replace(/‡µç‚Äç/g, "√§");

  E = txt.indexOf("‡µÜ*");
  N = txt.indexOf("‡µÜ*");
  M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡µç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "o" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡µÜ*");
    N = txt.indexOf("‡µÜ*");
    M = 1;
  }

  E = txt.indexOf("‡µá*");
  N = txt.indexOf("‡µá*");
  M = 1;
  while (E > -1) {
    while (txt[N - 2] == "‡µç" || txt[N - 2] == "√§") {
      M = M + 2;
      N = N - 2;
    }
    txt = txt.slice(0, E - M) + "O" + txt.slice(E - M, E) + txt.slice(E + 2);
    E = txt.indexOf("‡µá*");
    N = txt.indexOf("‡µá*");
    M = 1;
  }

  txt = txt
    .replace(/‡¥é\*/g, "oA")
    .replace(/‡¥è\*/g, "OA")
    .replace(/‡µÅ\*/g, "uAX")
    .replace(/‡¥â\*/g, "XAuAX");

  txt = txt.replace(/‡µÜ‡µà/g, "‡µà").replace(/‡µä‡µà/g, "‡µàa");

  //replace ‡µÜ with e
  e = txt.indexOf("‡µÜ");
  n = txt.indexOf("‡µÜ");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡µÜ");
    n = txt.indexOf("‡µÜ");
    m = 1;
  }

  //replace ‡µá with E
  e = txt.indexOf("‡µá");
  n = txt.indexOf("‡µá");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "E" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡µá");
    n = txt.indexOf("‡µá");
    m = 1;
  }

  //replace ‡µà with ee
  e = txt.indexOf("‡µà");
  n = txt.indexOf("‡µà");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt = txt.slice(0, e - m) + "ee" + txt.slice(e - m, e) + txt.slice(e + 1);
    e = txt.indexOf("‡µà");
    n = txt.indexOf("‡µà");
    m = 1;
  }

  e = txt.indexOf("‡µä");
  n = txt.indexOf("‡µä");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "e" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡µä");
    n = txt.indexOf("‡µä");
    m = 1;
  }

  e = txt.indexOf("‡µã");
  n = txt.indexOf("‡µã");
  m = 1;
  while (e > -1) {
    while (txt[n - 2] == "‡µç" || txt[n - 2] == "√§") {
      m = m + 2;
      n = n - 2;
    }
    txt =
      txt.slice(0, e - m) + "F" + txt.slice(e - m, e) + "a" + txt.slice(e + 1);
    e = txt.indexOf("‡µã");
    n = txt.indexOf("‡µã");
    m = 1;
  }

  H = txt.indexOf("‡¥∞‡µç");
  ra2 = txt[H + 2];
  while (H > -1) {
    if (
      /‡¥ï|‡¥ñ|‡¥ó|‡¥ò|‡¥ô|‡¥ö|‡¥õ|‡¥ú|‡¥ù|‡¥û|‡¥ü|‡¥†|‡¥°|‡¥¢|‡¥£|‡¥§|‡¥•|‡¥¶|‡¥ß|‡¥®|‡¥™|‡¥´|‡¥¨|‡¥≠|‡¥Æ|‡¥Ø|‡¥≤|‡¥µ|‡¥∂|‡¥∑|‡¥∏|‡¥π|‡¥≥/.test(
        ra2
      ) &&
      txt[H - 1] !== "‡µç"
    ) {
      txt = txt.slice(0, H) + txt[H + 2] + "f" + txt.slice(H + 3);
      H = txt.indexOf("‡¥∞‡µç");
      ra2 = txt[H + 2];
    } else {
      txt = txt.replace("‡¥∞‡µç", "rA");
      H = txt.indexOf("‡¥∞‡µç");
      ra2 = txt[H + 2];
    }
  }

  H = txt.indexOf("‡µº");
  ra2 = txt[H + 1];
  while (H > -1) {
    if (
      /‡¥ï|‡¥ñ|‡¥ó|‡¥ò|‡¥ô|‡¥ö|‡¥õ|‡¥ú|‡¥ù|‡¥û|‡¥ü|‡¥†|‡¥°|‡¥¢|‡¥£|‡¥§|‡¥•|‡¥¶|‡¥ß|‡¥®|‡¥™|‡¥´|‡¥¨|‡¥≠|‡¥Æ|‡¥Ø|‡¥≤|‡¥µ|‡¥∂|‡¥∑|‡¥∏|‡¥π|‡¥≥/.test(
        ra2
      ) &&
      txt[H - 1] !== "‡µç"
    ) {
      txt = txt.slice(0, H) + txt[H + 1] + "f" + txt.slice(H + 2);
      H = txt.indexOf("‡µº");
      ra2 = txt[H + 1];
    } else {
      txt = txt.replace("‡µº", "rA");
      H = txt.indexOf("‡µº");
      ra2 = txt[H + 1];
    }
  }

  txt = txt
    .replace(/‡¥Ö/g, "XAA")
    .replace(/‡¥Ü/g, "XAa")
    .replace(/‡¥á/g, "XAi")
    .replace(/‡¥à/g, "XAI")
    .replace(/‡¥â/g, "XAu")
    .replace(/‡¥ä/g, "XAU")
    .replace(/‡¥ã/g, "XAR")
    .replace(/‡µ†/g, "XARR")
    .replace(/‡µÑ/g, "RR")
    .replace(/‡¥é/g, "eA")
    .replace(/‡¥è/g, "EA")
    .replace(/‡¥ê/g, "eeA")
    .replace(/‡¥í/g, "eAa")
    .replace(/‡¥ì/g, "FAa")
    .replace(/‡¥î/g, "AY")
    .replace(/‡µó/g, "Y")
    .replace(/‡¥Ç/g, "M")
    .replace(/‡¥É/g, "H")
    .replace(/‡¥ï/g, "k")
    .replace(/‡¥ñ/g, "K")
    .replace(/‡¥ó/g, "g")
    .replace(/‡¥ò/g, "G")
    .replace(/‡¥ô/g, "Z")
    .replace(/‡¥ö/g, "c")
    .replace(/‡¥õ/g, "C")
    .replace(/‡¥ú/g, "j")
    .replace(/‡¥ù/g, "J")
    .replace(/‡¥û/g, "z")
    .replace(/‡¥ü/g, "q")
    .replace(/‡¥†/g, "Q")
    .replace(/‡¥°/g, "w")
    .replace(/‡¥¢/g, "W")
    .replace(/‡¥£/g, "N")
    .replace(/‡¥§/g, "t")
    .replace(/‡¥•/g, "T")
    .replace(/‡¥¶/g, "d")
    .replace(/‡¥ß/g, "D")
    .replace(/‡¥®/g, "n")
    .replace(/‡¥™/g, "p")
    .replace(/‡¥´/g, "P")
    .replace(/‡¥¨/g, "b")
    .replace(/‡¥≠/g, "B")
    .replace(/‡¥Æ/g, "m")
    .replace(/‡¥Ø/g, "y")
    .replace(/‡¥∞/g, "r")
    .replace(/‡¥≤/g, "l")
    .replace(/‡¥µ/g, "v")
    .replace(/‡¥∂/g, "S")
    .replace(/‡¥∑/g, "x")
    .replace(/‡¥∏/g, "s")
    .replace(/‡¥π/g, "h")
    .replace(/‡¥≥/g, "L")
    .replace(/‡µç/g, "A")
    .replace(/‡¥æ/g, "a")
    .replace(/‡µÅ/g, "u")
    .replace(/‡µÇ/g, "U")
    .replace(/‡µà/g, "Y")
    .replace(/‡¥ø/g, "i")
    .replace(/‡µÄ/g, "I")
    .replace(/‡µÉ/g, "R")
    .replace(/‚Äç/g, "X")
    .replace(/‚Äå/g, "X")
    .replace(/√§/g, "A");
  txt = txt
    .replace(/A /g, "A  ")
    .replace(/‡¥±/g, "r")
    .replace(/‡¥¥/g, "L")
    .replace(/‡µº/g, "rA")
    .replace(/‡µª/g, "nA")
    .replace(/‡µ∫/g, "NA")
    .replace(/‡µΩ/g, "lA")
    .replace(/‡µæ/g, "LA");

  let fa = txt.indexOf("fA");
  while (fa > -1) {
    var tt = [
      "k", "K", "g", "G", "Z", "c", "C", "j", "J", "z", "q", "Q", "w", "W", "N", "t", "T", "d", "D", "n", "p", "P", "b", "B", "m", "y", "r", "l", "v", "S", "x", "s", "h", "L",];

    if (tt.includes(txt[fa + 2])) {
      txt = txt.slice(0, fa) + "fXA" + txt.slice(fa + 2);
    }

    fa = txt.indexOf("fA", fa + 2);
  }

  return txt;
}


